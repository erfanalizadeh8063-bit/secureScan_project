name: Deploy ‚Üí Render

on:
  workflow_dispatch:
  push:
    branches: [ main ]

env:
  RENDER_API_BASE: https://api.render.com/v1

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install jq & curl (ensure)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Validate & normalize secrets
        id: norm
        env:
          RAW_KEY:   ${{ secrets.RENDER_API_KEY }}
          RAW_BACK:  ${{ secrets.RENDER_BACK_SERVICE_ID }}
          RAW_FRONT: ${{ secrets.RENDER_FRONT_SERVICE_ID }}
          RAW_BASE:  ${{ env.RENDER_API_BASE }}
        run: |
          set -e
          [ -n "$RAW_KEY" ]   || (echo "‚ùå Missing RENDER_API_KEY" && exit 1)
          [ -n "$RAW_BACK" ]  || (echo "‚ùå Missing RENDER_BACK_SERVICE_ID" && exit 1)
          [ -n "$RAW_FRONT" ] || (echo "‚ùå Missing RENDER_FRONT_SERVICE_ID" && exit 1)
          [ -n "$RAW_BASE" ]  || (echo "‚ùå Missing RENDER_API_BASE" && exit 1)
          KEY="$(printf %s "$RAW_KEY"   | tr -d '\r\n')"
          BACK="$(printf %s "$RAW_BACK"  | tr -d '\r\n \t')"
          FRONT="$(printf %s "$RAW_FRONT" | tr -d '\r\n \t')"
          BASE="$(printf %s "$RAW_BASE"  | tr -d '\r\n \t')"
          BASE="${BASE%/}"
          echo "BASE=$BASE"   >> "$GITHUB_OUTPUT"
          echo "BACK=$BACK"   >> "$GITHUB_OUTPUT"
          echo "FRONT=$FRONT" >> "$GITHUB_OUTPUT"
          echo "Normalized: $BASE/services/$BACK ; $BASE/services/$FRONT"

      - name: Fetch backend service info
        id: back_info
        env:
          BASE: ${{ steps.norm.outputs.BASE }}
          BACK: ${{ steps.norm.outputs.BACK }}
        run: |
          set -e
          KEY="${{ secrets.RENDER_API_KEY }}"
          curl -fsS -H "Accept: application/json" -H "Authorization: Bearer $KEY" \
            "$BASE/services/$BACK" > backend.json
          # URL may live in different fields; check them all
          cat backend.json | jq -r '
            .serviceDetails.url // .url // .service.url // empty
          ' > backend_url.txt
          sed -i 's:/*$::' backend_url.txt || true   # remove trailing slashes
          echo "Backend URL: $(cat backend_url.txt || echo '')"

      - name: Fetch frontend service info
        id: front_info
        env:
          BASE: ${{ steps.norm.outputs.BASE }}
          FRONT: ${{ steps.norm.outputs.FRONT }}
        run: |
          set -e
          KEY="${{ secrets.RENDER_API_KEY }}"
          curl -fsS -H "Accept: application/json" -H "Authorization: Bearer $KEY" \
            "$BASE/services/$FRONT" > frontend.json
          cat frontend.json | jq -r '
            .serviceDetails.url // .url // .service.url // empty
          ' > frontend_url.txt
          sed -i 's:/*$::' frontend_url.txt || true
          echo "Frontend URL: $(cat frontend_url.txt || echo '')"

      - name: Upsert frontend env VITE_API_URL (‚Üí backend)
        env:
          BASE: ${{ steps.norm.outputs.BASE }}
          FRONT: ${{ steps.norm.outputs.FRONT }}
        run: |
          set -e
          KEY="${{ secrets.RENDER_API_KEY }}"
          BACK_URL="$(cat backend_url.txt || true)"
          if [ -z "$BACK_URL" ]; then
            echo "‚ö†Ô∏è Backend URL not detected; skipping VITE_API_URL update"
            exit 0
          fi
          BODY="$(jq -nc --arg k VITE_API_URL --arg v "$BACK_URL" '{key:$k, value:$v, scope:"env"}')"
          # POST (create) ‚Üí if fails, PUT (update)
          curl -sS -X POST -H "Accept: application/json" -H "Content-Type: application/json" \
               -H "Authorization: Bearer $KEY" \
               -d "$BODY" \
               "$BASE/services/$FRONT/env-vars" \
          || curl -sS -X PUT -H "Accept: application/json" -H "Content-Type: application/json" \
               -H "Authorization: Bearer $KEY" \
               -d "$BODY" \
               "$BASE/services/$FRONT/env-vars"

      - name: Upsert backend env FRONT_ORIGIN (‚Üí frontend)
        env:
          BASE: ${{ steps.norm.outputs.BASE }}
          BACK: ${{ steps.norm.outputs.BACK }}
        run: |
          set -e
          KEY="${{ secrets.RENDER_API_KEY }}"
          FRONT_URL="$(cat frontend_url.txt || true)"
          if [ -z "$FRONT_URL" ]; then
            echo "‚ö†Ô∏è Frontend URL not detected; skipping FRONT_ORIGIN update"
            exit 0
          fi
          BODY="$(jq -nc --arg k FRONT_ORIGIN --arg v "$FRONT_URL" '{key:$k, value:$v, scope:"env"}')"
          curl -sS -X POST -H "Accept: application/json" -H "Content-Type: application/json" \
               -H "Authorization: Bearer $KEY" \
               -d "$BODY" \
               "$BASE/services/$BACK/env-vars" \
          || curl -sS -X PUT -H "Accept: application/json" -H "Content-Type: application/json" \
               -H "Authorization: Bearer $KEY" \
               -d "$BODY" \
               "$BASE/services/$BACK/env-vars"

      - name: Trigger FRONTEND deploy
        env:
          BASE: ${{ steps.norm.outputs.BASE }}
          FRONT: ${{ steps.norm.outputs.FRONT }}
        run: |
          set -e
          KEY="${{ secrets.RENDER_API_KEY }}"
          echo "üöÄ Triggering frontend deploy‚Ä¶"
          curl -fsS -X POST -H "Accept: application/json" \
               -H "Authorization: Bearer $KEY" \
               "$BASE/services/$FRONT/deploys"

      - name: Trigger BACKEND deploy
        env:
          BASE: ${{ steps.norm.outputs.BASE }}
          BACK: ${{ steps.norm.outputs.BACK }}
        run: |
          set -e
          KEY="${{ secrets.RENDER_API_KEY }}"
          echo "üöÄ Triggering backend deploy‚Ä¶"
          curl -fsS -X POST -H "Accept: application/json" \
               -H "Authorization: Bearer $KEY" \
               "$BASE/services/$BACK/deploys"

      - name: Wait for BACKEND health (/healthz)
        run: |
          set -e
          BACK_URL="$(cat backend_url.txt || true)"
          if [ -z "$BACK_URL" ]; then
            echo "‚ö†Ô∏è Backend URL unknown; skipping health check"
            exit 0
          fi
          echo "ü©∫ Polling $BACK_URL/healthz"
          for i in $(seq 1 20); do
            CODE=$(curl -s -o /dev/null -w "%{http_code}" "$BACK_URL/healthz" || echo 000)
            echo " attempt $i ‚Üí $CODE"
            [ "$CODE" = "200" ] && { echo "‚úÖ Backend healthy"; exit 0; }
            sleep 6
          done
          echo "‚ùå Backend not healthy in time"; exit 1

      - name: Wait for FRONTEND root
        run: |
          set -e
          FRONT_URL="$(cat frontend_url.txt || true)"
          if [ -z "$FRONT_URL" ]; then
            echo "‚ö†Ô∏è Frontend URL unknown; skipping"
            exit 0
          fi
          echo "üåê Polling $FRONT_URL"
          for i in $(seq 1 20); do
            CODE=$(curl -s -o /dev/null -w "%{http_code}" "$FRONT_URL" || echo 000)
            echo " attempt $i ‚Üí $CODE"
            [ "$CODE" = "200" ] || [ "$CODE" = "304" ] && { echo "‚úÖ Frontend serving"; exit 0; }
            sleep 6
          done
          echo "‚ùå Frontend not serving in time"; exit 1

      - name: Final URLs
        run: |
          echo "Backend URL : $(cat backend_url.txt  || echo 'unknown')"
          echo "Frontend URL: $(cat frontend_url.txt || echo 'unknown')"
